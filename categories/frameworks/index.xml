<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frameworks on Ed Zynda - Coder, Hacker, Superhero</title>
    <link>http://edzynda.com/categories/frameworks/index.xml</link>
    <description>Recent content in Frameworks on Ed Zynda - Coder, Hacker, Superhero</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Powered by [Hugo](http://gohugo.io).</copyright>
    <atom:link href="http://edzynda.com/categories/frameworks/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Create A Self-destructing, Encrypted Message App In Laravel Part 2</title>
      <link>http://edzynda.com/create-a-self-destructing-encrypted-message-app-in-laravel-part-2/</link>
      <pubDate>Mon, 18 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://edzynda.com/create-a-self-destructing-encrypted-message-app-in-laravel-part-2/</guid>
      <description>&lt;p&gt;The first thing we&amp;rsquo;ll need to do is create a default layout. This is the layout that the rest of our views will extend. Let&amp;rsquo;s save it as &amp;lsquo;app/views/layouts/default.blade.php&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;

    &amp;lt;title&amp;gt;Burnmsg - Self-desctructing, encrypted messages&amp;lt;/title&amp;gt;

    &amp;lt;!-- Bootstrap core CSS --&amp;gt;
    &amp;lt;link href=&amp;quot;{{ asset(&#39;css/styles.css&#39;) }}&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;

    &amp;lt;!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries --&amp;gt;
    &amp;lt;!--[if lt IE 9]&amp;gt;
      &amp;lt;script src=&amp;quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
      &amp;lt;script src=&amp;quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;![endif]--&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;

    &amp;lt;div class=&amp;quot;navbar navbar-inverse navbar-fixed-top&amp;quot; role=&amp;quot;navigation&amp;quot;&amp;gt;
      &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;navbar-header&amp;quot;&amp;gt;
          &amp;lt;a class=&amp;quot;navbar-brand&amp;quot; href=&amp;quot;{{ route(&#39;messages.create&#39;) }}&amp;quot;&amp;gt;Burnmsg&amp;lt;/a&amp;gt;
        &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        @yield(&#39;content&#39;)
    &amp;lt;/div&amp;gt;&amp;lt;!-- /.container --&amp;gt;


    &amp;lt;!-- Bootstrap core JavaScript
    ================================================== --&amp;gt;
    &amp;lt;!-- Placed at the end of the document so the pages load faster --&amp;gt;
    &amp;lt;script src=&amp;quot;https://code.jquery.com/jquery-1.10.2.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&amp;quot;{{ asset(&#39;js/bootstrap.min.js&#39;) }}&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to make sure that Twitter Bootstrap is accessible. Bootstrap is installed into the &amp;lsquo;vendor&amp;rsquo; folder of our project by composer. First let&amp;rsquo;s copy the Javascript libraries.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cp vendor/twitter/bootstrap/dist/js/bootstrap.min.js public/js  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need the CSS stylesheet but we are going to need to tweak some of the styles. We are going to do this using LESS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ touch public/css/styles.less  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our newly created LESS file we will import the original stylesheet and make our tweaks as needed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@import &amp;quot;../../vendor/twitter/bootstrap/less/bootstrap&amp;quot;;

body {
    padding-top: 65px; /* bring body to bottom of navbar */
}

article {
    white-space: pre-wrap;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LESS makes it easy to work with CSS but it needs to be &amp;ldquo;compiled&amp;rdquo; in order for the browser to understand it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ lessc public/css/styles.less &amp;gt; public/css/styles.css  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I use &amp;lsquo;lessc&amp;rsquo; which is a Ruby gem but you can use any LESS compiler. Google should bring up a handful of options.&lt;/p&gt;

&lt;p&gt;Now all that is left is to create our various views which correspond to the different actions involved in our application. Let&amp;rsquo;s save these views in &amp;lsquo;app/views/messages&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The first view &amp;lsquo;create.blade.php&amp;rsquo; will represent our message creation form. Notice that it &amp;lsquo;@extends&amp;rsquo; our default layout and renders the form within the &amp;lsquo;content&amp;rsquo; section which is referenced in the default layout.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    @extends(&#39;layouts.default&#39;)

    @section(&#39;content&#39;)
    {{ Form::open([&#39;method&#39; =&amp;gt; &#39;post&#39;, &#39;route&#39; =&amp;gt; &#39;messages.store&#39;, &#39;class&#39; =&amp;gt; &#39;form&#39;]) }}
    &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
        @if($errors-&amp;gt;first())
            &amp;lt;div class=&amp;quot;alert alert-danger&amp;quot;&amp;gt;
                {{ $errors-&amp;gt;first() }}
            &amp;lt;/div&amp;gt;
        @endif
        {{ Form::label(&#39;body&#39;, &#39;Message&#39;) }}
        {{ Form::textarea(&#39;body&#39;, null, [&#39;class&#39; =&amp;gt; &#39;form-control&#39;]) }}
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;form-group&amp;quot;&amp;gt;
        {{ Form::submit(&#39;Submit&#39;, [&#39;class&#39; =&amp;gt; &#39;btn btn-primary&#39;]) }}
        {{ Form::close() }}
    &amp;lt;/div&amp;gt;
    @stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once the message is submitted our &amp;lsquo;store.blade.php&amp;rsquo; view will display a link for the user to copy and give to whomever they wish for later reading.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    @extends(&#39;layouts.default&#39;)

    @section(&#39;content&#39;)
    &amp;lt;div class=&amp;quot;alert alert-success&amp;quot;&amp;gt;
        Your message has been saved.
        Here is the URL &amp;lt;a href=&amp;quot;{{ route(&#39;messages.show&#39;, [$url, $key]) }}&amp;quot;&amp;gt;{{ route(&#39;messages.show&#39;, [$url, $key]) }}&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
    @stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly the &amp;lsquo;show.blade.php&amp;rsquo; view will display the message for the user once they decide to read it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;    @extends(&#39;layouts.default&#39;)

    @section(&#39;content&#39;)
    &amp;lt;article&amp;gt;
    {{{ $body }}}
    &amp;lt;/article&amp;gt;
    @stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we should have a pretty sweet messaging app that destroys your message upon reading. Keep in mind that I am no cryptography or digital forensics expert so rely on this application at your own risk. Go ahead and modify it to make it more secure if you like. Leave any suggestions you may have in the comments.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create A Self-destructing, Encrypted Message App In Laravel Part 1</title>
      <link>http://edzynda.com/create-a-self-destructing-encrypted-message-app-in-laravel-part-1/</link>
      <pubDate>Fri, 15 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://edzynda.com/create-a-self-destructing-encrypted-message-app-in-laravel-part-1/</guid>
      <description>&lt;p&gt;The Internet is the wild west these days. With hackers, scammers and even governments gathering our personal communications, you may have become pretty paranoid about what you post online these days. In response to all this paranoia, there have been several offerings from online applications to SaaS services claiming to improve your security and protect your data online. I wouldn&amp;rsquo;t say that I fall into the paranoid category but security, anonymity and cryptography fascinate me.&lt;/p&gt;

&lt;p&gt;While brain storming one day, I decided to go ahead and build a self-destructing, encrypted messaging application in Laravel, using PHP&amp;rsquo;s built-in mcrypt library to see how hard it would be. Turns out it isn&amp;rsquo;t very hard at all.&lt;/p&gt;

&lt;p&gt;First we need to download Laravel and setup the base of our project. We&amp;rsquo;ll call it &amp;lsquo;Burnmsg&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ composer create-project laravel/laravel burnmsg  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s setup our composer.json file to fetch some dependencies. We&amp;rsquo;ll use Twitter&amp;rsquo;s bootstrap for styling and Jeffrey Way&amp;rsquo;s time-saving artisan generators.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;name&amp;quot;: &amp;quot;laravel/laravel&amp;quot;,
    &amp;quot;description&amp;quot;: &amp;quot;The Laravel Framework.&amp;quot;,
    &amp;quot;keywords&amp;quot;: [&amp;quot;framework&amp;quot;, &amp;quot;laravel&amp;quot;],
    &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
    &amp;quot;require&amp;quot;: {
        &amp;quot;laravel/framework&amp;quot;: &amp;quot;4.0.*&amp;quot;,
        &amp;quot;twitter/bootstrap&amp;quot;: &amp;quot;3.0.*&amp;quot;
        &amp;quot;way/generators&amp;quot;: &amp;quot;dev-master&amp;quot;
    },
    &amp;quot;autoload&amp;quot;: {
        &amp;quot;classmap&amp;quot;: [
            &amp;quot;app/commands&amp;quot;,
            &amp;quot;app/controllers&amp;quot;,
            &amp;quot;app/models&amp;quot;,
            &amp;quot;app/database/migrations&amp;quot;,
            &amp;quot;app/database/seeds&amp;quot;,
            &amp;quot;app/tests/TestCase.php&amp;quot;
        ]
    },
    &amp;quot;scripts&amp;quot;: {
        &amp;quot;post-install-cmd&amp;quot;: [
            &amp;quot;php artisan optimize&amp;quot;
        ],
        &amp;quot;post-update-cmd&amp;quot;: [
            &amp;quot;php artisan clear-compiled&amp;quot;,
            &amp;quot;php artisan optimize&amp;quot;
        ],
        &amp;quot;post-create-project-cmd&amp;quot;: [
            &amp;quot;php artisan key:generate&amp;quot;
        ]
    },
    &amp;quot;config&amp;quot;: {
        &amp;quot;preferred-install&amp;quot;: &amp;quot;dist&amp;quot;
    },
    &amp;quot;minimum-stability&amp;quot;: &amp;quot;dev&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure you add the generators service provider to &amp;lsquo;app/config/app.php&amp;rsquo; in the &amp;lsquo;providers&amp;rsquo; array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
&#39;providers&#39; = array(
    &#39;...&#39;,
    &#39;Way\Generators\GeneratorsServiceProvider&#39;
),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change your database configuration in &amp;lsquo;app/config/database.php&amp;rsquo;. Once that&amp;rsquo;s done we can generate our model, controller and views all in one command using the useful generators tool.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ php artisan generate:resource --fields=&amp;quot;body:binary,url:string,iv:binary,destroyed:boolean&amp;quot; messages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can run our migration to create the messages table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ php artisan migrate  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next let&amp;rsquo;s set up our routes. We only need a few. One for the message form. One to post the data and one to view our message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
Route::get(&#39;/&#39;, [&#39;as&#39; =&amp;gt; &#39;messages.create&#39;, &#39;uses&#39; =&amp;gt; &#39;MessagesController@create&#39;]);
Route::post(&#39;/&#39;, [&#39;as&#39; =&amp;gt; &#39;messages.store&#39;, &#39;uses&#39; =&amp;gt; &#39;MessagesController@store&#39;]);
Route::get(&#39;/{key}/{value}&#39;, [&#39;as&#39; =&amp;gt; &#39;messages.show&#39;, &#39;uses&#39; =&amp;gt; &#39;MessagesController@show&#39;]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our controller we will only need a create, store and show method. The create method will return the view for displaying our form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
public function create()
{
      return View::make(&#39;messages.create&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The store method will take the input and validate it. In this case we only care that the message isn&amp;rsquo;t left blank. Next we will generate a random key. Then we will generate an IV or initialization vector. This is used to improve the randomization of our encryption. In this case we will use the Blowfish algorithm. The last steps are to encrypt the message and then save the encrypted message and the IV for decryption later. We will also create a random identifier. The key will not be saved though. Instead it will be part of the URL for retrieving the message later. Because the key is part of the URL the message creator needs to keep this as safe as possible. This also prevents the person running the server from being able to read any of the messages. Plausible-deniability. Finally we return the view which displays the URL for our message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php  
public function store()
{
        // Validate input
        $v = Message::validate(Input::all());

        if ($v !== true) {
            return Redirect::route(&#39;messages.create&#39;)
                -&amp;gt;withErrors($v-&amp;gt;errors());
        }

        $msg = new Message;

        // Generate a key
        $key = sha1(microtime(true).mt_rand(10000,90000));

        // Generate an IV
        $iv_size = mcrypt_get_iv_size(MCRYPT_BLOWFISH, MCRYPT_MODE_CFB);
        $iv = mcrypt_create_iv($iv_size, MCRYPT_DEV_URANDOM);

        // Encrypt the message
        $body = mcrypt_encrypt(MCRYPT_BLOWFISH, $key, Input::get(&#39;body&#39;), MCRYPT_MODE_CFB, $iv);

        // Save the message to the database
        $msg-&amp;gt;body = $body;
        $msg-&amp;gt;url = Message::get_unique_url();
        $msg-&amp;gt;iv = $iv;
        $msg-&amp;gt;save();

        // Return the view
        return View::make(&#39;messages.store&#39;, [&#39;url&#39; =&amp;gt; $msg-&amp;gt;url, &#39;key&#39; =&amp;gt; $key]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The show method will take the random identifier and the key and decrypt the message. Once decrypted it will overwrite the message with &amp;lsquo;null&amp;rsquo; in the database and return the view displaying the one-time-viewable message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
public function show($url, $key)
{
        // Fetch our message
        $msg = Message::where(&#39;url&#39;, &#39;=&#39;, $url)-&amp;gt;first();

        if ($msg-&amp;gt;destroyed) {
            $body = &amp;quot;This message has been destroyed&amp;quot;;
        } else {
            // Decrypt it
            $iv = $msg-&amp;gt;iv;
            $body = mcrypt_decrypt(MCRYPT_BLOWFISH, $key, $msg-&amp;gt;body, MCRYPT_MODE_CFB, $iv);

            // Destroy the message
            $msg-&amp;gt;body = null;
            $msg-&amp;gt;destroyed = true;
            $msg-&amp;gt;save();
        }

        return View::make(&#39;messages.show&#39;, [&#39;body&#39; =&amp;gt; $body]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s take care of our model. The model will handle the validation as well as generating the random url identifier saved in the store method above.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

class Message extends Eloquent {
    protected $guarded = [&#39;id&#39;, &#39;created_at&#39;, &#39;updated_at&#39;];

    public static $rules = [&#39;body&#39; =&amp;gt; &#39;required&#39;];

    public static function validate($input)
    {
        $v = Validator::make($input, static::$rules);
        return $v-&amp;gt;fails() ? $v : true;
    }

    public static function  get_unique_url() {

         // set a random number
        $number = rand(10000, 9999999);

                // character list for generating a random string
        $charlist = &amp;quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;;

        $decimal = intval($number);

        //get the list of valid characters
        $charlist = substr($charlist, 0, 62);

        $converted = &#39;&#39;;

        while($number &amp;gt; 0) {
            $converted = $charlist{($number % 62)} . $converted;
            $number = floor($number / 62);
        }

        if( static::whereUrl($converted)-&amp;gt;first() ) {
            static::get_unique_url();
        }

                return $converted;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have most of the hard part out of the way. All that is left is to create and style the various views using Twitter Bootstrap which will be covered in part 2.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>What Is A Microframework? Getting Started With Silex</title>
      <link>http://edzynda.com/what-is-a-microframework-getting-started-with-silex/</link>
      <pubDate>Wed, 13 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>http://edzynda.com/what-is-a-microframework-getting-started-with-silex/</guid>
      <description>&lt;p&gt;There is no shortage of coding frameworks these days. I can&amp;rsquo;t scroll through my twitter and facebook feeds or my favorite dev forums without stumbling upon something new. Like a hungry barracuda, I&amp;rsquo;m instantly attracted to new shiny things. While browsing reddit.com/r/php I came across a mention of a microframework called &lt;a href=&#34;http://silex.sensiolabs.org/&#34; title=&#34;Silex&#34; target=&#34;_blank&#34;&gt;Silex&lt;/a&gt;. Now you may be wondering what a microframework is. I was wondering the same thing, so I took a look at the project&amp;rsquo;s website to figure out for myself.&lt;/p&gt;

&lt;p&gt;It turns out that a microframework, just like the name implies, is just a barebones framework meant to give the developer access to powerful tools without the bulk of a full-on framework. Silex is a microframework which utilizes components from the popular &lt;a href=&#34;http://symfony.com/&#34; title=&#34;Symfony2&#34; target=&#34;_blank&#34;&gt;Symfony2&lt;/a&gt; framework. In fact it&amp;rsquo;s written and maintained by the same people at Sensiolabs. It&amp;rsquo;s meant for applications consisting of usually one php file but you can definitely build something much bigger. Installing and using Silex is pretty straight-forward especially if you are familiar with other modern PHP frameworks.&lt;/p&gt;

&lt;p&gt;Like all modern PHP projects you start with a composer.json file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;require&amp;quot;: {
        &amp;quot;silex/silex&amp;quot;: &amp;quot;~1.1&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run composer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ composer install  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now create a public facing directory with an index.php file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir public  
$ touch index.php  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should end up with the following directory structure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;├── composer.json  
├── composer.lock  
├── vendor  
│ └── ...  
└── public  
└── index.php  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to bootstrap Silex so we can start using it in our index.php file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
// public/index.php
 
require_once __DIR__.&#39;/../vendor/autoload.php&#39;;
 
$app = new Silex\Application;
 
// definitions
 
$app-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above snippet, we&amp;rsquo;ve created an instance of Silex called &amp;lsquo;$app&amp;rsquo;. Now we can use &amp;lsquo;$app&amp;rsquo; to define things like routes and service providers before calling &amp;lsquo;$app-&amp;gt;run()&amp;rsquo; which will load our application.&lt;/p&gt;

&lt;p&gt;Defining routes is pretty simple. For each route you need to know the method (e.g. GET or POST), the URI pattern you want to match and method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
// public/index.php
 
require_once __DIR__.&#39;/../vendor/autoload.php&#39;;
 
use Symfony\Component\HttpFoundation\Request;
 
$app = new Silex\Application;
 
// definitions
$app-&amp;gt;get(&#39;/&#39;, function()
{
    return &#39;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;/&amp;quot;&amp;gt;Enter your name: &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; /&amp;gt;&amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot; /&amp;gt;&amp;lt;/form&amp;gt;&#39;;
});
 
$app-&amp;gt;post(&#39;/&#39;, function(Request $request)
{
    $name = $request-&amp;gt;get(&#39;name&#39;);
    return &amp;quot;Hello! Welcome &amp;quot; . $name . &amp;quot;!&amp;quot;;
});
 
$app-&amp;gt;run();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, we defined two routes. The GET request returns a form which is then handled by our POST route once it is submitted. To access the variables passed in our POST request we use Symfony&amp;rsquo;s HttpFoundation\Request component and the &amp;lsquo;get()&amp;rsquo; method. An instance of of Request is automatically injected into our route closure by Silex using type-hinting or what I like to call magic.&lt;/p&gt;

&lt;p&gt;Hopefully from this tutorial you can get an idea for how to create a small yet powerful app using Silex.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Repositories In Laravel</title>
      <link>http://edzynda.com/using-repositories-in-laravel/</link>
      <pubDate>Fri, 18 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://edzynda.com/using-repositories-in-laravel/</guid>
      <description>&lt;p&gt;The past couple of days I have been cramming my brain with coding knowledge. I&amp;#8217;m working on a side project that I&amp;#8217;ll likely announce in detail as it gets closer to launch. Since I&amp;#8217;m starting from an empty Laravel project and building it from the ground up, I&amp;#8217;m learning quite a bit about the framework and even some of the new features in PHP 5.4 and above.&lt;/p&gt;

&lt;p&gt;One technique I&amp;#8217;m starting to better understand is that of dependency injection. Dependency injection sounds scary at first but it&amp;#8217;s really a simple concept and has the potential to improve the flexibility of your projects. Laravel allows you to take dependency injection a step further with it&amp;#8217;s powerful IoC container.&lt;/p&gt;

&lt;p&gt;If you&amp;#8217;ve frequented web development forums or IRC channels lately, you might hear seasoned veterans blabbing about the merits of TDD or Test Driven Development. It&amp;#8217;s another concept that sounds scary at first but really isn&amp;#8217;t once you start digging into it. Basically TDD preaches that you should write automated tests for your code &lt;strong&gt;before&lt;/strong&gt; you even write a single line of production code. Not only that, you should be writing tests that work with a single component at a time, in isolation. If you follow the single responsibility principle when writing code, this shouldn&amp;#8217;t be too hard.&lt;/p&gt;

&lt;p&gt;What if your class or controller methods depend on another class that has it&amp;#8217;s own responsibilities? Theoretically those classes should have their own tests and should be isolated from your own tests. How do we do this though? The answer is dependency injection.&lt;/p&gt;

&lt;p&gt;Dependency injection is simply passing the classes your current class depends on through the constructor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class UserController extends BaseController {
    protected $dependency;

    public function __construct(Dependency $dependency)
    {
        $this-&amp;gt;dependency = $dependency;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;#8217;s it. Not too scary right? This way, when you write your automated tests, you can now &amp;#8216;mock&amp;#8217; those classes with a tool like Mockery and inject them from inside your test code. If those dependencies accessed a database or live filesystem you can rest assured your tests will not because those dependencies are now mocked or stubbed.&lt;/p&gt;

&lt;p&gt;So dependency injection is great for testing but it has other benefits. Let&amp;#8217;s say in laravel you have a UserController. That controller has a method that fetches all users and sends them to a view.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class UserController extends BaseController {

    public function index()
    {
        $users = User::all();
        return View::make(&#39;users.list&#39;, compact($users));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s very simple to call our User model and just call methods from within the controller. But this will create a nightmare for testing and isn&amp;rsquo;t very flexible. Why not inject the User model?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class UserController extends BaseController {
    protected $user;

    public function __construct(User $user)
    {
        $this-&amp;gt;user = $user;
    }
    public function index()
    {
        $users $this-&amp;gt;user-&amp;gt;all();
        return View::make(&#39;users.list&#39;, compact($users));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay that&amp;#8217;s great but say one day you decide to go with a different implementation of your users like MongoDB or a flatfile database? You&amp;#8217;ll have to go through your code and clean out and refactor anything that references the Laravel models because they extend Eloquent which uses an SQL database. This is where the idea of using repositories comes in.&lt;/p&gt;

&lt;p&gt;First let&amp;#8217;s create an interface. Think of an interface as a contract. Any class that implements this interface must also implement its methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php namespace Stark\Repositories;

interface UserRepositoryInterface {
    public function getAll();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll store it in a custom directory called &amp;lsquo;Stark/Repositories&amp;rsquo;. Notice that the namespace goes along with the directory structure. Now let&amp;rsquo;s create a class that implements this interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php namespace Stark\Repositories;

use User;

class EloquentUserRepository implements UserRepositoryInterface {
    public function getAll()
    {
        return User::all();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool. Now let&amp;rsquo;s just refactor our controller to use our interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

use Stark\Repositories\UserRespositoryInterface as Repository;

class UserController extends BaseController {
    protected $user;

    public function __construct(Repository $user)
    {
        $this-&amp;gt;user = $user;
    }
    public function index()
    {
        $users $this-&amp;gt;user-&amp;gt;getAll();
        return View::make(&#39;users.list&#39;, compact($users));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now remember that interfaces are cannot be instantiated but Laravel is smart enough to inject a proper class in it&amp;#8217;s place if you give it some hints. First we have to make sure our &amp;#8216;Stark&amp;#8217; namespace is autoloaded. For that we edit our composer.json file and add the namespace and it&amp;#8217;s location under &amp;#8220;psr-0&amp;#8243;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;autoload&amp;quot;: {
        &amp;quot;psr-0&amp;quot;: {
            &amp;quot;Stark&amp;quot;: &amp;quot;app/&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we tell Laravel that anytime we reference UserRepositoryInterface we really want EloquentUserRepository. We can do that in our &amp;#8216;app/routes.php&amp;#8217; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
App::bind(&#39;Stark\Repositories\UserRepositoryInterface&#39;, &#39;Stark\Repositories\EloquentUserRepository&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we decide to use some other storage method we can simply code another repository that implements the UserRepositoryInterface and change that one line in the routes file to reflect the change. The rest of your app couldn&amp;#8217;t care less.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started With Laravel 4 and Vagrant</title>
      <link>http://edzynda.com/getting-started-with-laravel-4-and-vagrant/</link>
      <pubDate>Tue, 20 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>http://edzynda.com/getting-started-with-laravel-4-and-vagrant/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve worked with a handful of different PHP frameworks over the years. From ZEND Framework to Codeigniter, all have their pros and cons. Some of them are more difficult to work with than others. None of them, however, have been more enjoyable for me to work with than Laravel.&lt;/p&gt;

&lt;p&gt;I came across Laravel while randomly browsing the web. I don&amp;rsquo;t even remember what I was looking for but after reading more about Laravel and how simple it was to setup, I was hooked. In this article I&amp;rsquo;ll take you through setting up a PHP development environment for Laravel 4.&lt;/p&gt;

&lt;p&gt;In this tutorial, I will also be introducing you to a utility called Vagrant. Vagrant makes it ridiculously easy to create a virtual machine in which to run and test your web applications. It uses VirtualBox as a backend and is pretty straightforward once you get into it. No more fussing with WAMP, XAMP, or MAMP environments. You can easily create a small virtual machine that more closely resembles your production environment with a just few commands.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Install VirtualBox and Vagrant&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;On a standard Debian or Ubuntu box you should be able to run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo apt-get install virtualbox  
$ sudo apt-get install vagrant  
$ sudo apt-get install linux-headers-$(uname -r)  
$ sudo dpkg-reconfigure virtualbox-dkms  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This installs VirtualBox, Vagrant and it&amp;rsquo;s dependencies. It also compiles the various kernel modules needed for VirtualBox to run correctly.&lt;/p&gt;

&lt;p&gt;On my Gentoo box, I run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ emerge virtualbox  
$ emerge virtualbox-modules  
$ emerge vagrant  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. Setup The Vagrant Environment&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Vagrant&amp;rsquo;s virtual machines instances are based on prebuilt configurations called &amp;lsquo;boxes&amp;rsquo;. The following command will download a box based on Ubuntu Precise Pangolin (32bit) and name it &amp;lsquo;precise32&amp;#8242;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vagrant box add precise32 http://files.vagrantup.com/precise32.box  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You now no longer have to download that box and can create any number of VM instances based on this build.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir my_dev_env
$ cd my_dev_env
$ vagrant init precise32
$ vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it! You now have a fully functioning Ubuntu VM ready to play around with. To work with the VM run&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vagrant ssh  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you will notice that the VM doesn&amp;rsquo;t automatically have a webserver or mysql or really anything needed for a development environment installed. You can go ahead and install everything you need manually but fortunately, Vagrant is scriptable. You can go ahead and write a script to install everything you need after running &amp;lsquo;vagrant up&amp;rsquo; but why do that when it can be done for you?&lt;/p&gt;

&lt;p&gt;Head on over to PuPHPet to see what I mean.&lt;/p&gt;

&lt;p&gt;This handy GUI will take you through configuring a Vagrant environment that&amp;rsquo;s functional as soon as it boots up.&lt;/p&gt;

&lt;p&gt;First select &amp;lsquo;Create Locally&amp;rsquo;. Next, for this tutorial we&amp;rsquo;ll select Debian Wheezy as our base. There&amp;rsquo;s no reason to change the vagrant box name but you can change the &amp;lsquo;Name Your Box&amp;rsquo; section if you wish. You can also change the ip address that this VM will be accessed from.&lt;/p&gt;

&lt;p&gt;One final thing I do in this section is change the default sync folder to &amp;lsquo;./work&amp;rsquo;. I&amp;rsquo;ll explain why later.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.edzynda.com/media/PuPHPet-step-1-.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-259&#34; alt=&#34;PuPHPet-step-1-&#34; src=&#34;http://www.edzynda.com/media/PuPHPet-step-1-.png&#34; width=&#34;680&#34; height=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;On the Server Basics section you can safely leave everything as default. If you want to add things like your own personal aliases file, you can add that here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.edzynda.com/media/PuPHPet-step-2.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-260&#34; alt=&#34;PuPHPet-step-2&#34; src=&#34;http://www.edzynda.com/media/PuPHPet-step-2.png&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;For the HTTP Server I choose Nginx because it&amp;rsquo;s awesome. Choose the host name you want to use for you dev environment. We&amp;rsquo;ll add that to our /etc/hosts file later for easy access. Everything else can safely stay the same.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.edzynda.com/media/PuPHPet-step-3.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-263&#34; alt=&#34;PuPHPet-step-3&#34; src=&#34;http://www.edzynda.com/media/PuPHPet-step-3.png&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I keep everything here as default as well. Make sure &amp;lsquo;Install Composer&amp;rsquo; is checked. We&amp;rsquo;ll need that to install Laravel later. You can add any other PHP modules you want if you wish.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.edzynda.com/media/PuPHPet-step-4.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-264&#34; alt=&#34;PuPHPet-step-4&#34; src=&#34;http://www.edzynda.com/media/PuPHPet-step-4.png&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The Database section should be pretty straightforward. Just create a root password and setup a non-root user.&lt;a href=&#34;http://www.edzynda.com/media/PuPHPet-step-5.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-265&#34; alt=&#34;PuPHPet-step-5&#34; src=&#34;http://www.edzynda.com/media/PuPHPet-step-5.png&#34; width=&#34;640&#34; height=&#34;400&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally you can hit &amp;lsquo;Create My Manifest&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.edzynda.com/media/PuPHPet-step-6.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-266&#34; alt=&#34;PuPHPet-step-6&#34; src=&#34;http://www.edzynda.com/media/PuPHPet-step-6.png&#34; width=&#34;640&#34; height=&#34;280&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Once the .zip file has finished downloading run the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ unzip wheezy64.zip  
$ mv wheezy64 laravel_dev  
$ cd laravel_dev  
$ ls  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll notice that this directory is cluttered with stuff. Normally Vagrant uses the top level directory of your environment to sync with a folder on the VM. In this case it will sync with &amp;lsquo;/var/www&amp;rsquo;. This comes in handy for developing on the local machine. Remember that we chose &amp;lsquo;./work&amp;rsquo; as our local sync directory back in the GUI. It&amp;rsquo;s not created by default, so we have to create it ourselves. After that we can start Vagrant as normal.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir work  
$ vagrant up  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test to make sure everything is working run the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo echo &#39;192.168.56.101 laravel.dev&#39; &amp;gt;&amp;gt; /etc/hosts  
$ cd work  
$ echo &#39;&amp;lt;?php phpinfo(); ?&amp;gt;&#39; &amp;gt; index.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &amp;lsquo;laravel.dev&amp;rsquo; should be replaced with whatever you named your virtualhost back in the GUI. Open your web browser of choice and go to &amp;lsquo;&lt;a href=&#34;http://laravel.dev&#39;&#34;&gt;http://laravel.dev&#39;&lt;/a&gt; and you should see the familiar PHP Info page.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Install Laravel&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now to install Laravel we are going to use Composer which is an easy utility for installing various PHP related software such as the Laravel framework.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vagrant ssh  
$ cd /var/www  
$ composer create-project laravel/laravel your-project-name --prefer-dist  
$ exit  
$ chmod -R 777 my-project/app/storage  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now point your web browser to &amp;lsquo;&lt;a href=&#34;http://laravel.dev/my-project/public&#39;&#34;&gt;http://laravel.dev/my-project/public&#39;&lt;/a&gt;. You may have to &amp;lsquo;chmod -R 777&amp;#8242; the storage directory one more time as Laravel creates a &amp;lsquo;session&amp;rsquo; directory that needs to be writeable.&lt;/p&gt;

&lt;p&gt;If all goes well you should see the Laravel welcome screen stating that &amp;#8220;You Have Arrived.&amp;#8221;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.edzynda.com/media/laravel-success.jpg&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-270&#34; alt=&#34;laravel-success&#34; src=&#34;http://www.edzynda.com/media/laravel-success-300x168.jpg&#34; width=&#34;300&#34; height=&#34;168&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Congratulations! You should now have a functioning Laravel 4 development environment.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>